<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>saturnin: saturnin::Clause Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">saturnin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classsaturnin_1_1_clause.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classsaturnin_1_1_clause-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">saturnin::Clause Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_clause_8h_source.html">Clause.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsaturnin_1_1_clause_1_1compact__t.html">compact_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a413b0a57e086f303fdc170249046b20d"><td class="memItemLeft" align="right" valign="top">Lit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a413b0a57e086f303fdc170249046b20d">getLit</a> (unsigned int pos) const </td></tr>
<tr class="separator:a413b0a57e086f303fdc170249046b20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298cc5582bc07a823996b7fb9686ba8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a0298cc5582bc07a823996b7fb9686ba8">setLit</a> (unsigned int pos, Lit l)</td></tr>
<tr class="separator:a0298cc5582bc07a823996b7fb9686ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173e4fd08463e66ce8e22f5832fa4507"><td class="memItemLeft" align="right" valign="top">Lit &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a173e4fd08463e66ce8e22f5832fa4507">operator[]</a> (unsigned int pos)</td></tr>
<tr class="separator:a173e4fd08463e66ce8e22f5832fa4507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91469744731bc7030a3ac86c1c31d904"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a91469744731bc7030a3ac86c1c31d904">getLBD</a> () const </td></tr>
<tr class="separator:a91469744731bc7030a3ac86c1c31d904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001e1e1a5502cbbc187e83be064c6d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a001e1e1a5502cbbc187e83be064c6d31">setLBD</a> (unsigned int v)</td></tr>
<tr class="separator:a001e1e1a5502cbbc187e83be064c6d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5434619825ec91203ad7a841b4db05a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#ab5434619825ec91203ad7a841b4db05a">isLearnt</a> () const </td></tr>
<tr class="separator:ab5434619825ec91203ad7a841b4db05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345e75ad5895c477b298caa04e0d2f02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a345e75ad5895c477b298caa04e0d2f02">operator Lit *</a> ()</td></tr>
<tr class="separator:a345e75ad5895c477b298caa04e0d2f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f984d0bbc195ddb3a6797ee98ac5309"><td class="memItemLeft" align="right" valign="top">Lit *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a9f984d0bbc195ddb3a6797ee98ac5309">lits</a> ()</td></tr>
<tr class="separator:a9f984d0bbc195ddb3a6797ee98ac5309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ce97a39ddea99d4c6ff04b934d2198"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#ab5ce97a39ddea99d4c6ff04b934d2198">operator const Lit *</a> () const </td></tr>
<tr class="separator:ab5ce97a39ddea99d4c6ff04b934d2198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e2e01e2829b4f5230da8e2eb606db8"><td class="memItemLeft" align="right" valign="top">const Lit *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a16e2e01e2829b4f5230da8e2eb606db8">lits</a> () const </td></tr>
<tr class="separator:a16e2e01e2829b4f5230da8e2eb606db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310d072c95b78a63fc3fd52acecf9da9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a310d072c95b78a63fc3fd52acecf9da9">getSize</a> () const </td></tr>
<tr class="separator:a310d072c95b78a63fc3fd52acecf9da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a5090923923828bcabbbfd3de6342d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a57a5090923923828bcabbbfd3de6342d">removeLit</a> (unsigned int pos)</td></tr>
<tr class="separator:a57a5090923923828bcabbbfd3de6342d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ffbfad1ad29f73bf58e4731333219b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a30ffbfad1ad29f73bf58e4731333219b">setIndex</a> (unsigned int idx)</td></tr>
<tr class="separator:a30ffbfad1ad29f73bf58e4731333219b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ec01d34cdbb5e1350ecd2ebbe7ab9f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a46ec01d34cdbb5e1350ecd2ebbe7ab9f">getIndex</a> () const </td></tr>
<tr class="separator:a46ec01d34cdbb5e1350ecd2ebbe7ab9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ea10fb4de7850f80a7a3f4d737ade7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a58ea10fb4de7850f80a7a3f4d737ade7">swapLiterals</a> (unsigned int posA, unsigned int posB)</td></tr>
<tr class="separator:a58ea10fb4de7850f80a7a3f4d737ade7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6e0705f3a6fb088a1e8183e2377aa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#aaf6e0705f3a6fb088a1e8183e2377aa6">contains</a> (Lit l) const </td></tr>
<tr class="separator:aaf6e0705f3a6fb088a1e8183e2377aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9330e14e293b3da45d14a6fd031d106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#aa9330e14e293b3da45d14a6fd031d106">isSatisfied</a> (const <a class="el" href="classsaturnin_1_1_array.html">Array</a>&lt; wbool &gt; &amp;interpretation) const </td></tr>
<tr class="separator:aa9330e14e293b3da45d14a6fd031d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356dec923b21b13dd9f382125245b981"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a356dec923b21b13dd9f382125245b981">isAttached</a> () const </td></tr>
<tr class="separator:a356dec923b21b13dd9f382125245b981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36be6ccd61c68a056b5bde1ac82b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a8b36be6ccd61c68a056b5bde1ac82b0a">setAttached</a> (bool at)</td></tr>
<tr class="separator:a8b36be6ccd61c68a056b5bde1ac82b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c799904cf1b85410662dcaee0395db"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a98c799904cf1b85410662dcaee0395db">getFreezeCounter</a> () const </td></tr>
<tr class="separator:a98c799904cf1b85410662dcaee0395db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6970a54eba831fde7103d181e89a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#afb6970a54eba831fde7103d181e89a7d">incrementFreezeCounter</a> ()</td></tr>
<tr class="separator:afb6970a54eba831fde7103d181e89a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab355789bc4e139c48ef3f87d85e6331f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#ab355789bc4e139c48ef3f87d85e6331f">resetFreezeCounter</a> ()</td></tr>
<tr class="separator:ab355789bc4e139c48ef3f87d85e6331f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd93c7abfc614b9506fb4cce6b6233a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a0dd93c7abfc614b9506fb4cce6b6233a">operator==</a> (const <a class="el" href="classsaturnin_1_1_clause.html">Clause</a> &amp;other) const </td></tr>
<tr class="separator:a0dd93c7abfc614b9506fb4cce6b6233a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cac2cc363c639992bb78842e63f542d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a2cac2cc363c639992bb78842e63f542d">~Clause</a> ()</td></tr>
<tr class="separator:a2cac2cc363c639992bb78842e63f542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc402b5c4a2abc8e30ad86e2da473bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fc402b5c4a2abc8e30ad86e2da473bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Clause</b> (const <a class="el" href="classsaturnin_1_1_clause.html">Clause</a> &amp;)=delete</td></tr>
<tr class="separator:a1fc402b5c4a2abc8e30ad86e2da473bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae820c0774e5c5e4c02ad987f35e2ea93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae820c0774e5c5e4c02ad987f35e2ea93"></a>
<a class="el" href="classsaturnin_1_1_clause.html">Clause</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsaturnin_1_1_clause.html">Clause</a> &amp;)=delete</td></tr>
<tr class="separator:ae820c0774e5c5e4c02ad987f35e2ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a5aca55d1e39821baedd1e68ae6a7f233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a5aca55d1e39821baedd1e68ae6a7f233">Clause</a> (const Lit *const literals, unsigned int sz, unsigned int lbd=0)</td></tr>
<tr class="separator:a5aca55d1e39821baedd1e68ae6a7f233"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0f42dab820d6c2cc2f0e90a61638fafa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a0f42dab820d6c2cc2f0e90a61638fafa">size</a></td></tr>
<tr class="separator:a0f42dab820d6c2cc2f0e90a61638fafa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f823749bd6f25dd9f88d6126c56e50b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsaturnin_1_1_clause_1_1compact__t.html">compact_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#a6f823749bd6f25dd9f88d6126c56e50b">compact</a></td></tr>
<tr class="separator:a6f823749bd6f25dd9f88d6126c56e50b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d444a2d1f43ae5289d4b589403e239"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#aa7d444a2d1f43ae5289d4b589403e239">index</a></td></tr>
<tr class="separator:aa7d444a2d1f43ae5289d4b589403e239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045419537421a7f17d5edf85b86abc0"><td class="memItemLeft" align="right" valign="top">Lit&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsaturnin_1_1_clause.html#ab045419537421a7f17d5edf85b86abc0">data</a> [1]</td></tr>
<tr class="separator:ab045419537421a7f17d5edf85b86abc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af75e6cfcc40248f1afa95af8feb6ba5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af75e6cfcc40248f1afa95af8feb6ba5a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PoolList</b></td></tr>
<tr class="separator:af75e6cfcc40248f1afa95af8feb6ba5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represent a clause. In order to be memory efficient, the array containing the literals (data) is defined as a 0-length array at the end of the class. This way, if we want to have a clause of length 3, we may allocate the whole clause as one chunk of memory, and the end of the memory may be used for the literals. However, this implementation has a drawback. We can't use the 'normal' way of instantiate the clause (Clause* c = new <a class="el" href="classsaturnin_1_1_clause.html">Clause</a>(...)) as it won't reserve enough space for the literals. This mean that we have to use a dedicated allocator. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2cac2cc363c639992bb78842e63f542d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">saturnin::Clause::~Clause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<a class="anchor" id="a5aca55d1e39821baedd1e68ae6a7f233"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">saturnin::Clause::Clause </td>
          <td>(</td>
          <td class="paramtype">const Lit *const&#160;</td>
          <td class="paramname"><em>literals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>lbd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classsaturnin_1_1_clause.html">Clause</a>. Should only be called from <a class="el" href="classsaturnin_1_1_pool_list.html">PoolList</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">literals</td><td>the array containing the literals </td></tr>
    <tr><td class="paramname">sz</td><td>the number of literals in this clause, and in <em>literals</em> </td></tr>
    <tr><td class="paramname">lbd</td><td>the literal block distance of the clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaf6e0705f3a6fb088a1e8183e2377aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool saturnin::Clause::contains </td>
          <td>(</td>
          <td class="paramtype">Lit&#160;</td>
          <td class="paramname"><em>l</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check that the clause contains a given literal </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>the literal to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the literal is present, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a98c799904cf1b85410662dcaee0395db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int saturnin::Clause::getFreezeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the value of the freeze counter The freeze counter is used to represent the number of times this clause has been frozen </p>
<dl class="section return"><dt>Returns</dt><dd>the value of the freeze counter </dd></dl>

</div>
</div>
<a class="anchor" id="a46ec01d34cdbb5e1350ecd2ebbe7ab9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int saturnin::Clause::getIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the index linked to this clause </p>
<dl class="section return"><dt>Returns</dt><dd>the index for this clause </dd></dl>

</div>
</div>
<a class="anchor" id="a91469744731bc7030a3ac86c1c31d904"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int saturnin::Clause::getLBD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the literal block distance of the clause. This measure will only be available if the clause was learnt.</p>
<p>For more information, please look at <b>Gilles Audemard</b>, <b>Laurent Simon</b>, <em>"Predicting Learnt Clauses Quality in Modern
SAT Solver"</em>. In Twenty-first International Joint Conference on Artificial Intelligence (IJCAI'09), pp. 399-404, july 2009. </p>
<dl class="section return"><dt>Returns</dt><dd>the lbd of the clause </dd></dl>

</div>
</div>
<a class="anchor" id="a413b0a57e086f303fdc170249046b20d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Lit saturnin::Clause::getLit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the n-th literal of the clause </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the literal we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested literal </dd></dl>

</div>
</div>
<a class="anchor" id="a310d072c95b78a63fc3fd52acecf9da9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int saturnin::Clause::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the size of this clause </p>
<dl class="section return"><dt>Returns</dt><dd>the size of the clause </dd></dl>

</div>
</div>
<a class="anchor" id="afb6970a54eba831fde7103d181e89a7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::incrementFreezeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Increment the frozen counter </p>

</div>
</div>
<a class="anchor" id="a356dec923b21b13dd9f382125245b981"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool saturnin::Clause::isAttached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if this clause is attached to a solver </p>
<dl class="section return"><dt>Returns</dt><dd>true if the clause is attached to a solver </dd></dl>

</div>
</div>
<a class="anchor" id="ab5434619825ec91203ad7a841b4db05a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool saturnin::Clause::isLearnt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the clause was learnt or is part of the original instance.</p>
<p><b> To determine this, we use the implicit invariant through the code that when a clause is learnt (=generated), we always specify its literal block distance </b> </p>
<dl class="section return"><dt>Returns</dt><dd>true if the clause was learnt (=generated), false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aa9330e14e293b3da45d14a6fd031d106"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool saturnin::Clause::isSatisfied </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaturnin_1_1_array.html">Array</a>&lt; wbool &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpretation</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the given clause is satisfied by the given interpretation </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interpretation</td><td>the wbool array that will provide the value of the n-th variable at position n </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the clause is satisfied </dd></dl>

</div>
</div>
<a class="anchor" id="a9f984d0bbc195ddb3a6797ee98ac5309"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Lit* saturnin::Clause::lits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to obtain direct access to literal array </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the array containing the literals </dd></dl>

</div>
</div>
<a class="anchor" id="a16e2e01e2829b4f5230da8e2eb606db8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Lit* saturnin::Clause::lits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to obtain direct access to literal array </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the array containing the literals </dd></dl>

</div>
</div>
<a class="anchor" id="ab5ce97a39ddea99d4c6ff04b934d2198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">saturnin::Clause::operator const Lit * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to obtain direct access to literal array </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the array containing the literals </dd></dl>

</div>
</div>
<a class="anchor" id="a345e75ad5895c477b298caa04e0d2f02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">saturnin::Clause::operator Lit * </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allows to obtain direct access to literal array </p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the array containing the literals </dd></dl>

</div>
</div>
<a class="anchor" id="a0dd93c7abfc614b9506fb4cce6b6233a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool saturnin::Clause::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsaturnin_1_1_clause.html">Clause</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two clauses are equals. Two clauses are equals if they have the same size and if they both contain the same set of literals. The complexity of this method is O(n²) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other clause to compare to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this clause and <em>other</em> are equals </dd></dl>

</div>
</div>
<a class="anchor" id="a173e4fd08463e66ce8e22f5832fa4507"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Lit&amp; saturnin::Clause::operator[] </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the n-th literal of the clause </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the literal we want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the requested literal </dd></dl>

</div>
</div>
<a class="anchor" id="a57a5090923923828bcabbbfd3de6342d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::removeLit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the element at a given position </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the element we remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab355789bc4e139c48ef3f87d85e6331f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::resetFreezeCounter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the freeze counter to its initial value </p>

</div>
</div>
<a class="anchor" id="a8b36be6ccd61c68a056b5bde1ac82b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::setAttached </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>at</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the attachment of this clause True meaning that the clause is currently attached, false means otherwise </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">at</td><td>the new value of the attachment of this clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30ffbfad1ad29f73bf58e4731333219b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::setIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the index for this clause </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>the index to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a001e1e1a5502cbbc187e83be064c6d31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::setLBD </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specify the literal block distance value of the clause </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the new value of the lbd </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0298cc5582bc07a823996b7fb9686ba8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::setLit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Lit&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of a given literal </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the position of the literal we want to change </td></tr>
    <tr><td class="paramname">l</td><td>the new value for the literal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a58ea10fb4de7850f80a7a3f4d737ade7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void saturnin::Clause::swapLiterals </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>posA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>posB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the literal at the given positions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">posA</td><td>the position of the first literal </td></tr>
    <tr><td class="paramname">posB</td><td>the position of the second literal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6f823749bd6f25dd9f88d6126c56e50b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsaturnin_1_1_clause_1_1compact__t.html">compact_t</a> saturnin::Clause::compact</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The variable containing some data about the close in a compact way </p>

</div>
</div>
<a class="anchor" id="ab045419537421a7f17d5edf85b86abc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Lit saturnin::Clause::data[1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array that will contain the literals The size has been set to 1 to have some data and be able to use the pedantic option of the compilers </p>

</div>
</div>
<a class="anchor" id="aa7d444a2d1f43ae5289d4b589403e239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int saturnin::Clause::index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An index that can be used by the user of the clause </p>

</div>
</div>
<a class="anchor" id="a0f42dab820d6c2cc2f0e90a61638fafa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int saturnin::Clause::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The length of the clause </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/bhoessen/saturnin/include/saturnin/<a class="el" href="_clause_8h_source.html">Clause.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>saturnin</b></li><li class="navelem"><a class="el" href="classsaturnin_1_1_clause.html">Clause</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
