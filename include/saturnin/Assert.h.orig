/*
Copyright (c) <2012> <B.Hoessen>

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.

   3. This notice may not be removed or altered from any source
   distribution.
 */

#ifndef SATURNIN_ASSERT_H
#define	SATURNIN_ASSERT_H


#ifdef DEBUG

#include "Logger.h"

#include <assert.h>
#include <stdlib.h>

#if defined _WIN32 || defined __CYGWIN__

#define SATURNIN_TRACE(logger) {}

#elif SUNSTUDIO

#define SATURNIN_TRACE(logger) {}

#else
#include <execinfo.h>
#include <cxxabi.h>



#include "Logger.h"

#define MAX_FRAMES 100

//Code for SATURNIN_TRACE obtained at:
//http://mykospark.net/2009/09/runtime-backtrace-in-c-with-name-demangling/
//In order to work, binaries must be compiled with the -rdynamic option
#define SATURNIN_TRACE(logger) {void* addresses[MAX_FRAMES];\
    int bt_size = backtrace(addresses, MAX_FRAMES);\
    char** symbols = backtrace_symbols(addresses, bt_size);\
    for (int x = 0; x < bt_size; ++x) {\
        size_t dem_size;\
        int status;\
        char temp[512];\
        char* demangled;\
        if (1 == sscanf(symbols[x], "%*[^(]%*[^_]%511[^)+]", temp)) {\
          if (nullptr != (demangled = abi::__cxa_demangle(temp, nullptr, &dem_size, &status))) {\
            logger << "#" << x << " " << demangled << "\n";\
            free(demangled);\
          }\
        }else if (1 == sscanf(symbols[x], "%511s", temp)) {\
          logger << "#" << x << " " << temp << "\n";\
        }else {\
          logger << "#" << x << " " << symbols[x] << "\n";\
        }\
    }\
    free(symbols);\
}
#endif

extern unsigned long _saturnin_nb_assert_;

namespace saturnin {

    template<typename T, typename B>
    void checkEquality(const T& expected, const T& actual, const char* nameEx, const char* nameAct, const char* fileName, int lineNb, B& out) {
        _saturnin_nb_assert_++;
        if (expected != actual) {
            out << nameEx << " == " << nameAct << " is not respected\n";
            out << "Expected: " << expected << "\n";
            out << "Actual:   " << actual << "\n";
            out << "In " << fileName << ":" << lineNb << "\n";
            SATURNIN_TRACE(out);
            assert((expected) == (actual));
        }
    }

    template<typename B>
    inline void checkTruth(bool condition, const char* nameCond, const char* fileName, int lineNb, B& out) {
        _saturnin_nb_assert_++;
        if (!(condition)) {
            out << nameCond << " is not respected\n";
            out << "In " << fileName << ":" << lineNb << "\n";
            SATURNIN_TRACE(out);
            assert(condition);
        }

    }
}

#include <string.h>
#define SATURNIN_FILENAME  "AFILE"  //(strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)

#define ASSERT(condition) {saturnin::checkTruth(condition, #condition, SATURNIN_FILENAME, __LINE__, saturnin::Logger::getStdErrLogger());}

#define ASSERT_EQUAL(expected, actual) {saturnin::checkEquality(expected, actual, #expected, #actual, SATURNIN_FILENAME, __LINE__, saturnin::Logger::getStdErrLogger());}

#define SKIP { int __skip_tmp = 0; __skip_tmp++;}

#define NB_ASSERTED _saturnin_nb_assert_

#else

namespace saturnin {

    template<typename T, typename B>
    void checkEquality(const T&, const T&, const char*, const char*, const char*, int, B&) { }

    template<typename B>
    inline void checkTruth(bool , const char* , const char* , int , B& ) { }

}
#define ASSERT(condition) {}
#define ASSERT_EQUAL(a, b) {}
#define SKIP {}
#define NB_ASSERTED 0
#define SATURNIN_TRACE(a) {}
#endif

#endif	/* SATURNIN_ASSERT_H */

