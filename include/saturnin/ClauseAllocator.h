/*
Copyright (c) <2012> <B.Hoessen>

This file is part of saturnin.

saturnin is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

saturnin is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with saturnin.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SATURNIN_CLAUSEALLOCATOR_H
#define	SATURNIN_CLAUSEALLOCATOR_H

#include "PoolList.h"
#include "Saturnin.h"

namespace saturnin{

    /**
     * This class represent a ClauseAllocator: the only object that is allowed
     * to create a clause
     */
    class SATURNIN_EXPORT ClauseAllocator final {
    public:

        /**
         * Create a new Clause allocator
         * It will allocate memory to hold @a maxSize times @a maxLength clauses
         * @param maxSize the initial maximum size of the clauses
         * @param maxLenght the initial maximum number of clauses of a given
         *                  size
         */
        ClauseAllocator(unsigned int maxSize, unsigned int maxLenght);

        /**
         * Destructor.
         * Every clause that was generated with this clause allocator won't be
         * usable anymore
         */
        ~ClauseAllocator();

        /**
         * Create a new clause
         * @param lits the array containing the literals
         * @param sz the number of literals in the array @a list
         * @param lbd the literal block distance of the clause
         * @return the clause of size @a sz containing the literals in @a lits
         *         and having the literal block distance set to @a lbd
         */
        Clause* createClause(const Lit* const lits, unsigned int sz, unsigned int lbd = 0);

        /**
         * Create a new clause
         * @param lits the array containing the literals
         * @param lbd the literal block distance of the clause
         * @return the clause containing the literals in @a lits
         *         and having the literal block distance set to @a lbd
         */
        Clause* createClause(const Array<Lit>& lits, unsigned int lbd = 0);

        /**
         * Release a clause that was generated by this clause allocator
         * @param c the clause to release
         */
        void releaseClause(Clause*& c);

        /**
         * Remove the last empty pools
         */
        void clearup();
        
        /**
         * Retrieve the memory footprint of this Array
         * @return the memory allocated in bytes for this array
         */
        inline size_t getMemoryFootprint() const{
            size_t mem = pools.getMemoryFootprint();
            for(unsigned int i=0; i<pools.getSize(); i++){
                mem += pools[i]->getMemoryFootprint();
            }
#ifdef PROFILE
            mem += clauseRepartition.getMemoryFootprint();
#endif /* PROFILE */
            return mem;
        }

        /**
         * Retrieve the number of pools used
         * @return the number of pools
         */
        inline unsigned int getNbPools() const{
            return pools.getSize();
        }

        /**
         * Retrieve a given pool
         * @param idx the index of the pool wanted
         * @return the pool containing clauses with sizes i*2 and i*2 + 1
         */
        inline const PoolList& getPool(unsigned int idx) const{
            return *(pools.get(idx));
        }

#ifdef PROFILE
        /** Retrieve the array containing the number of clause made by this allocator for a given size*/
        const Array<unsigned int>& getClauseRepartition() const { return clauseRepartition; }
#endif /* PROFILE */

    private:

        /**
         * The array containing every PoolList that will effectively contain
         * the clauses. The clauses of size n and n+1 (where n+1 % 2 ==0)
         * will be stored in the same pool
         */
        Array<PoolList*> pools;
        /** The initial size of the pools */
        unsigned int initialPoolSize;

#ifdef PROFILE
        Array<unsigned int> clauseRepartition;
#endif /* PROFILE */

        //! @cond Doxygen_Suppress
        //private and non implemented
        /** MAY NOT BE USED (private and not implemented) */
        ClauseAllocator(const ClauseAllocator& );
        /** MAY NOT BE USED (private and not implemented) */
        ClauseAllocator& operator=(const ClauseAllocator& );
        //! @endcond

    };

}

#endif	/* SATURNIN_CLAUSEALLOCATOR_H */

