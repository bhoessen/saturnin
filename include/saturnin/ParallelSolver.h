/*
Copyright (c) <2012> <B.Hoessen>

This file is part of saturnin.

saturnin is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

saturnin is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with saturnin.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SATURNIN_PARALLELSOLVER_H
#define	SATURNIN_PARALLELSOLVER_H

#ifdef SATURNIN_PARALLEL

#include <atomic>
#include "Array.h"
#include "CNFReader.h"
#include "Clause.h"
#include "Saturnin.h"

namespace saturnin{
    
    /** Forward declaration of the solver class */
    class Solver;
    
    /**
     * This class is used to use different solvers in a portfolio mode.
     * When in this mode, different solvers are lunched and share their learnt
     * clauses.
     */
    class SATURNIN_EXPORT ParallelSolver final {
    public:
        
        /**
         * Creates a new parallel solver.
         * @param nbSolvers the number of solvers that should be run in parallel
         */
        ParallelSolver(unsigned int nbSolvers);
        
        /**
         * Destructor
         */
        ~ParallelSolver();
        
        /**
         * Initialize the solvers
         * @param reader the reader that contains the different clauses
         * @param dbFileName the name of the file to use to store the database
         * @return true if we were able to add all the clauses, false if we
         *         reached an inconsistent state
         */
        bool initialize(const CNFReader& reader, const char* dbFileName = nullptr);
        
        /**
         * Start the parallel search
         * @param maxNbRestarts the maximum number of restart allowed
         * @return true if a result has been found, false otherwise
         */
        bool solve(unsigned int maxNbRestarts);
        
        /**
         * Retrieve the state of the solver
         * @return wTrue if a solution has been found, wFalse if UNSAT has been
         *         proven, wUnknown otherwise
         */
        wbool getState() const;
        
        /**
         * Retrieve the memory footprint of this parallel solver.
         * It will compute the memory footprint of every object used by this
         * parallel solver
         * @return the memory footprint in bytes
         */
        size_t getMemoryFootprint() const;
        
        /**
         * Set the verbosity of the underlying solvers
         * @param verb the verbosity level
         */
        void setVerbosity(unsigned int verb){
            verbosity = verb;
        }
        
        /**
         * Add a presumption
         * @param v the variable we presume its value
         * @param value the truth value that is supposed to be assigned
         */
        void addPresumption(Var v, bool value);
        
        /**
         * Retrieve the winning solver if any, otherwise, return the first
         * solver
         * @return the winning solver or the first if no winning solver
         */
        Solver& getWinningSolver();
        
        /**
         * stop the underlying solvers
         */
        void stop();
        
    private:
        
        friend class Solver;
        /** The number of solving thread we will use */
        unsigned int nbThreads;
        
        /**
         * This variable controls the verbosity of the solvers. The higher the
         * value is, the more information will be printed on the standard logger
         */
        unsigned int verbosity;
        
        /** The array containing the solvers that are run in parallel*/
        Array<Solver*> solvers;
        
        /** If true, a solution has been found */
        std::atomic<bool> solutionFound;
        
        /** The index of the solver that was first to find a solution */
        std::atomic<unsigned int> winningSolver;
        
        /** 
         * The array containing the clauses to be exchanged.
         * The clause at exchangedClause[i][j][k] is a clause that needs to be
         * imported by the i-th solver, generated by the j-th solver.
         * The value of k should be included in the range firstNonIncludedClause[i][j]
         * and freeNonIncludedClause[i][j] excluded
         * Therefore, if freeNonIncludedClause[i][j] == firstNonIncludedClause[i][j]
         * then there is no clause to import
         */
        Array<Array<Array<Clause*> > > exchangedClauses;
        /** 
         * The maximum number of clauses that can be waiting to be included
         * by another solver
         */
        unsigned int maxNbExchanged;
        /** 
         * The value firstNonIncludedClause[i][j] provide the index of the first
         * non included clause by the solver i, where the clause was generated
         * by the solver j
         */
        Array<Array<std::atomic<unsigned int> > > firstNonIncludedClause;
        /** 
         * The value freeNonIncludedClause[i][j] provide the index of the first
         * position where a clause that can be added by solver j in order to
         * be included by solver i
         */
        Array<Array<std::atomic<unsigned int> > > freeNonIncludedClause;
        
        /**
         * The array containing the proven literals that needs to be exchanged
         * The literal exhcangedLiterals[i][j][k] is a literal that needs to be
         * included by the solver i, literal generated by the solver j
         */
        Array<Array<Array<Lit> > > exchangedLiterals;
        /** The maximum number of proven literals that can be waiting */
        unsigned int maxNbProvenLit;
        /** 
         * The value firstNonIncludedLiteral[i][j] provide the index of the first
         * non included literal by the solver i, where the literal was generated
         * by the solver j
         */
        Array<Array<std::atomic<unsigned int> > > firstNonIncludedLiteral;
        /** 
         * The value lastNonIncludedLiteral[i][j] provide the index of the first
         * position where a literal that can be added by solver j in order to
         * be included by solver i
         */
        Array<Array<std::atomic<unsigned int> > > freeNonIncludedLiteral;
        
        //! @cond Doxygen_Suppress
        //private and non declared as it may not be used
        /** MAY NOT BE USED (private and not implemented) */
        ParallelSolver(const ParallelSolver&);
        /** MAY NOT BE USED (private and not implemented) */
        ParallelSolver& operator=(const ParallelSolver&);
        //! @endcond
    };
}

#endif /* SATURNIN_PARALLEL */

#endif	/* SATURNIN_PARALLELSOLVER_H */

