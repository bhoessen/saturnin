/*
Copyright (c) <2012> <B.Hoessen>

This file is part of saturnin.

saturnin is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
any later version.

saturnin is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with saturnin.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef SATURNIN_POOLLIST_H
#define	SATURNIN_POOLLIST_H

#include "Array.h"
#include "VariablesManager.h"
#include "Saturnin.h"

namespace saturnin {
    
#ifndef SATURNIN_POOLLIST_UPDATE_FACTOR
#define SATURNIN_POOLLIST_UPDATE_FACTOR 1.65
#endif

    //pre-def
    class Clause;

    /**
     * The PoolList class is a class that provide access to an allocator of
     * clauses of the same size. And whenever an object isn't used anymore,
     * it is going back to the pool. When a new object is requested, we first
     * provide element that are available in the pool. If we ran out of
     * available object, new clauses will be created, without modifying the
     * memory location of other clauses
     */
    class SATURNIN_EXPORT PoolList final {
    public:

        /**
         * Creates a new PoolList
         * @param clauseLength the length of the clauses that will be held in
         *                     the pool
         * @param nbClauses the initial number of clauses we want
         */
        PoolList(unsigned int clauseLength, unsigned int nbClauses);

        /**
         * Destructor.
         * It will also destroy the memory of every active clauses, without
         * using their respective destructor
         */
        ~PoolList();

        /**
         * Request for a new Clause
         * @param literals the array containing the literals of the clause that
         *                 must be created
         * @param sz the number of literals present in @a literals
         * @param lbd the literal block distance of the clause that will be
         *            created
         * @return the requested clause
         */
        Clause* createClause(const Lit* const literals, unsigned int sz, unsigned int lbd = 0);

        /**
         * Release a clause
         * @param c the clause to release. The value of the pointer will be set
         *          to nullptr after
         */
        void releaseClause(Clause*& c);

        /**
         * Retrieve the capacity of this PoolList
         * @return the maximum number of Clause that this object can hold before
         *         a new call to malloc needs to be performed
         */
        inline unsigned int getCapacity() const {
            return cap;
        }

        /**
         * Retrieve the current number of clauses used that were generated by
         * this PoolList
         * @return the current number of clauses used that were generated by
         *         this PoolList
         */
        inline unsigned int getSize() const {
            return size;
        }

        /**
         * Retrieve the number of clause that are still available in this
         * PoolList
         * @return the number of clauses that can be obtained through this
         *         PoolList before a call to malloc is needed
         */
        inline unsigned int getNbAvailableClauses() const {
            return availableClauses.getSize();
        }

        /**
         * Retrieve the length of the clauses that will be generated by this
         * PoolList
         * @return the maximum size of the clause that are generated by this
         *         PoolList
         */
        inline unsigned int getClausesLength() const {
            return clauseLength;
        }
        
        /**
         * Retrieve the memory footprint of this Array
         * @return the memory allocated in bytes for this array
         */
        size_t getMemoryFootprint() const;

    private:

        /** Memory chuncks used for the PoolList */
        typedef struct mchunks_t {
            /** Pointer to the actual memory chunk */
            char* chunck;
            /** The size of the chunk */
            unsigned int chunkSize;
            /** Pointer to the next memory chunk */
            struct mchunks_t* next;
        } mchunks;

        /** An array used as a fifo containing the available Clauses */
        Array<Clause*> availableClauses;
        /** The list of memory chunks */
        mchunks* memory;
        /** The size of the clauses managed by this PoolList */
        unsigned int clauseLength;
        /** The capacity of this pool (in Clause*) */
        unsigned int cap;
        /** The current number of clauses used that were generated by this PoolList*/
        unsigned int size;

        //! @cond Doxygen_Suppress
        PoolList(const PoolList&) = delete;
        PoolList operator=(const PoolList&) = delete;
        //! @endcond

    };

}

#endif	/* POOLLIST_H */

